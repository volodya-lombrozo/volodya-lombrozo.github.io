---
layout: post
title: "Review: Complete Shadow Symbolic Execution with Java PathFinder"
date: 2023-06-13
---

This is the review of the "Complete Shadow Symbolic Execution with Java
PathFinder"
article that you can find
right [here](https://dl.acm.org/doi/10.1145/3364452.33644558).

# Meta

This article is written by five authors from Germany:
Yannic Noller, Minxing Tang, Hoang Lam Nguyen, Lars Grunske and Timo Kehrer.
Published at [ACM SIGSOFT October 2019](https://dl.acm.org/newsletter/sigsoft).

Keywords: _Regression Testing, Symbolic Execution, Symbolic PathFinder_

| Conference  | Track                        | Year | Authors | Citations | Pages | Figures | References | Formals |
|-------------|------------------------------|------|---------|-----------|-------|---------|------------|---------|
| ACM SIGSOFT | Software and its engineering | 2019 | 4       | 3         | 5     | 6       | 16         | Absent  |

As you can see from the table above, this article is not so popular and has
practical value mostly.

# What is the study about?

Actually the article describes the possible way to generate test cases for
Java programs. The approach is based on Shadow Symbolic
Execution ([SSE](https://dl.acm.org/doi/10.1145/3208952)) which was
described in 2018 year and is just a continuation on this topic. In other words,
the approach described in the article allows to generate quite precise
tests based on the diff changes (patches) in the code.
When the old SSE approach has some limitations on finding regression bugs,
the new approach claims to find missed bugs for the expense of total
algorithm execution time. In other words SSE was looking for some particular
paths of the Symbolic Execution Tree, when the new approach claims to look
through all possible paths.

# Contribution

So, the authors state the next contributions:

* They propose a new approach to generate test cases based on combination of
  complete symbolic execution with the idea of four-way forking.
* The working tool that proves the idea of the article SHADOW JPF+ (extension
  for SHADOW JPF).
* The evaluation of the implemented tool based on some examples
  including [Joda-Time](https://www.joda.org/joda-time/) library.

Let's try to observe if they achieved their goals.

# Review

In this section I will provide a simple review from my personal point of view
and will try to decide what is the best parts in the article and what can
be improved in order to make the article better.

## Problem statement

The authors provide rather good explanation of the current state-of-the-art
of the problem. They describe the main idea of the Symbolic Execution,
Shadow Symbolic Execution and the main problems of the current approaches, like:

- "Deeper divergence might be missed in the BSE phase"
- "The initial input has to cover potential divergence point"

Both of the points actually emphasize the main problem of the current
SSE solution - it just can't find all possible paths of the Symbolic Execution
that could lead to the bug and the new solution addresses that problem.

So, we can say that the problem statement is clear and the authors provide
a good explanation of the current state-of-the-art and what they are trying to
solve.

## Innovation

As for innovation - it's actually hard to say something, one the one hand - it's
significant improvement of the previous approach, but on the other hand - it's
just a programming solution and the small step in the direction of the
Symbolic Execution improvement. So, I would say that the innovation is
rather small and have a practical value mostly. In other words it is just a
software solution that still have significant limitations in performance.
Moreover, we don't know about practical usage of the solution even after
four years after the article was published.
on the other hand, as I mentioned previuosely, contribution was stated clearly
and the authors achieved their goals (see [Contribution](#contribution) section
for details).

## Evaluation

Well, to be honest, it is most contradictory part of the article. The authors
provide a good explanation of the evaluation process:

> We selected the following software artifacts as our experimental subjects
> from the official SPF repository1 (with the corresponding LOC): Rational.abs (
> 30), Rational.gcd (40), Ratio- nal.simplify (51), WBS.update (234) and
> WBS.launch (242) and generated in total 79 mutants with the Major mutation
> framework with the following change types: Relational
> Operator Replacement (ROR), Operator Replacement Unary (ORU), Arithmetic
> Operator Replacement (AOR) and State- ment Deletion (STD).

As you can see, the max number of LOC is 242, which is not so much. Actually, it
is small number especially for practical use. I would like to see more complex
examples with lots of LOC and more complex logic, even if the results would be
worse. Honesty on the first place.

## Readability

It is definitely worth to mention that the article is written in a good way.
In the first place it is easy to read and understand the main idea of the
article. The authors provide a good explanation of the main concepts and
background. Moreover, the article is well structured and has a logical flow,
contributions, research questions, results (despite my previous comment about
it). All of these parts are presented clearly. Maybe, a lot of people
underestimate formatting, but personally to me, it is one of the important parts
of the article, and in this case it is done well:

- All the parts have their own suitable formatting (title, code samples,
  figure names, etc.)
- Code samples have suitable font and coloring
- Tables and figures are placed in the right places, have suitable
  descriptions, clearly represent all the required information

In general, I would like to recommend the same formatting style for all other
technical articles.

# Conclusion

So, in general I would like to recommend the article for reading to whom, who is
really interesting in Symbolic Execution topic and especially in Shadow Symbolic
Execution technique. The solution described suggests interesting and applicable
algorithm for improving the original SSE algorithm. You can find interesting
the final tool that was evaluated and tested. Despite some possible critique
it's important to mention that article is mostly engineering, not research, and
suggests practical steps for algorithm improving. The best trait of the article
is "Readability", the worst is "Evaluation". Anyway, it's important to have such
articles that step-by-step improves software techniques and technologies.





